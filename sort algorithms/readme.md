## 冒泡排序
**思想：** 前后比较-交换。实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换，每一次循环能够确定最后一个元素。该算法是稳定排序算法。

**稳定排序算法：** 一般情况下，称某个排序算法稳定，指的是当待排序序列中有相同的元素时，它们的相对位置在排序前后不会发生改变。

**时间复杂度：O(n^2)，空间复杂度：O(1)**


## 选择排序
**思想：** 选择较小的数据放在前面。工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。不稳定。

**时间复杂度：O(n^2)，空间复杂度：O(1)**

## 插入排序
**思想：** 逐个插入到前面的有序数中。每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。稳定。

**时间复杂度：O(n^2)，空间复杂度：O(1)**

## 希尔排序
**思想：** 从大范围到小范围进行比较-交换，类似冒泡和插入的联合。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

**时间复杂度：O(n^2)，空间复杂度：O(1)** 

希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。代码选择的二分增量最坏时间复杂度仍然是O(n^2)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n^1.5)。不稳定。

## 归并排序
**思想：** 分治法2-4-8插入排序。利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。稳定。

**时间复杂度：O(nlog(n))，空间复杂度：O(n)** 

每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。

## 快速排序
**思想：** 选取一个基准值，小数在左大数在右。通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。不稳定。

**时间复杂度：O(nlog(n))**(平均)，最坏O(n^2) **空间复杂度：O(log(n))**

快速排序是一种交换类的排序，它同样是分治法的经典体现。在一趟排序中将待排序的序列分割成两组，其中一部分记录的关键字均小于另一部分。然后分别对这两组继续进行排序，以使整个序列有序。在分割的过程中，枢纽值的选择至关重要，可以采取三位取中法，可以很大程度上避免分组"一边倒"的情况。快速排序平均时间复杂度也为O(nlogn)级。

## 堆排序
**思想：** 利用最大堆和最小堆的特性。堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。不稳定。

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

**时间复杂度：O(nlog(n))，空间复杂度：O(1)** 




